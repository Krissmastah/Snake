"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = exports._createClient = exports.createClient = void 0;
const hrana = __importStar(require("@libsql/hrana-client"));
const isomorphic_fetch_1 = require("@libsql/isomorphic-fetch");
const api_js_1 = require("./api.js");
const config_js_1 = require("./config.js");
const help_js_1 = require("./help.js");
const hrana_js_1 = require("./hrana.js");
const uri_js_1 = require("./uri.js");
__exportStar(require("./api.js"), exports);
function createClient(config) {
    return _createClient((0, config_js_1.expandConfig)(config));
}
exports.createClient = createClient;
/** @private */
function _createClient(config) {
    let scheme = config.scheme.toLowerCase();
    if (scheme === "libsql") {
        scheme = "https";
    }
    if (scheme !== "https" && scheme !== "http") {
        throw new api_js_1.LibsqlError('The HTTP client supports only "libsql", "https" and "http" URLs, ' +
            `got ${JSON.stringify(config.scheme)}. For more information, please read ${help_js_1.supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
    }
    const url = (0, uri_js_1.encodeBaseUrl)(scheme, config.authority, config.path);
    return new HttpClient(url, config.authToken);
}
exports._createClient = _createClient;
class HttpClient {
    #url;
    #authToken;
    closed;
    /** @private */
    constructor(url, authToken) {
        this.#url = url;
        this.#authToken = authToken;
        this.closed = false;
    }
    async execute(stmt) {
        try {
            const hranaStmt = (0, hrana_js_1.stmtToHrana)(stmt);
            const protoStmt = hrana.raw.stmtToProto(hranaStmt, true);
            const request = { "stmt": protoStmt };
            const response = await this.#send("POST", "v1/execute", request);
            const protoStmtResult = response["result"];
            const hranaRows = hrana.raw.rowsResultFromProto(protoStmtResult);
            return (0, hrana_js_1.resultSetFromHrana)(hranaRows);
        }
        catch (e) {
            throw (0, hrana_js_1.mapHranaError)(e);
        }
    }
    async batch(stmts) {
        try {
            const protoSteps = [];
            protoSteps.push({
                "stmt": { "sql": "BEGIN", "want_rows": false },
            });
            const beginStepIdx = protoSteps.length - 1;
            let lastStepIdx = beginStepIdx;
            for (const stmt of stmts) {
                const hranaStmt = (0, hrana_js_1.stmtToHrana)(stmt);
                protoSteps.push({
                    "condition": { "type": "ok", "step": lastStepIdx },
                    "stmt": hrana.raw.stmtToProto(hranaStmt, true),
                });
                lastStepIdx = protoSteps.length - 1;
            }
            protoSteps.push({
                "condition": { "type": "ok", "step": lastStepIdx },
                "stmt": { "sql": "COMMIT", "want_rows": false },
            });
            const commitStepIdx = protoSteps.length - 1;
            protoSteps.push({
                "condition": {
                    "type": "not",
                    "cond": { "type": "ok", "step": commitStepIdx },
                },
                "stmt": { "sql": "ROLLBACK", "want_rows": false },
            });
            const protoBatch = { "steps": protoSteps };
            const request = { "batch": protoBatch };
            const response = await this.#send("POST", "v1/batch", request);
            const protoBatchResult = response["result"];
            for (let stepIdx = beginStepIdx; stepIdx <= commitStepIdx; ++stepIdx) {
                const protoError = protoBatchResult["step_errors"][stepIdx];
                if (protoError !== null) {
                    throw hrana.raw.errorFromProto(protoError);
                }
            }
            const resultSets = [];
            for (let i = 0; i < stmts.length; ++i) {
                const stepIdx = beginStepIdx + 1 + i;
                const protoStmtResult = protoBatchResult["step_results"][stepIdx];
                if (protoStmtResult === null) {
                    throw new api_js_1.LibsqlError("Server did not return a result for statement in a batch", "SERVER_ERROR");
                }
                const hranaRows = hrana.raw.rowsResultFromProto(protoStmtResult);
                resultSets.push((0, hrana_js_1.resultSetFromHrana)(hranaRows));
            }
            return resultSets;
        }
        catch (e) {
            throw (0, hrana_js_1.mapHranaError)(e);
        }
    }
    async transaction() {
        throw new api_js_1.LibsqlError("The HTTP client does not support interactive transactions. " +
            'Please use a "libsql:", "ws:" or "wss:" URL to connect to the server over a WebSocket. ' +
            `For more information, please read ${help_js_1.supportedUrlLink}`, "TRANSACTIONS_NOT_SUPPORTED");
    }
    close() {
        this.closed = true;
    }
    async #send(method, path, reqBody) {
        if (this.closed) {
            throw new api_js_1.LibsqlError("The client is closed", "CLIENT_CLOSED");
        }
        const url = new URL(path, this.#url);
        const headers = {};
        if (this.#authToken !== undefined) {
            headers["authorization"] = `Bearer ${this.#authToken}`;
        }
        const resp = await (0, isomorphic_fetch_1.fetch)(url, {
            method,
            headers,
            body: JSON.stringify(reqBody),
        });
        const respType = resp.headers.get("content-type") ?? "text/plain";
        if (!resp.ok) {
            if (respType === "application/json") {
                const respBody = await resp.json();
                if ("message" in respBody) {
                    const code = respBody["code"] ?? "UNKNOWN";
                    throw new api_js_1.LibsqlError(respBody["message"], code);
                }
            }
            else if (respType === "text/plain") {
                const respBody = await resp.text();
                throw new api_js_1.LibsqlError(`Server returned HTTP status ${resp.status} and error: ${respBody}`, "SERVER_ERROR");
            }
            throw new api_js_1.LibsqlError(`Server returned HTTP status ${resp.status}`, "SERVER_ERROR");
        }
        return await resp.json();
    }
}
exports.HttpClient = HttpClient;
