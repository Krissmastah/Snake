"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sqlite3Transaction = exports.Sqlite3Client = exports._createClient = exports.createClient = void 0;
const better_sqlite3_1 = __importDefault(require("better-sqlite3"));
const node_buffer_1 = require("node:buffer");
const api_js_1 = require("./api.js");
const config_js_1 = require("./config.js");
const help_js_1 = require("./help.js");
__exportStar(require("./api.js"), exports);
function createClient(config) {
    return _createClient((0, config_js_1.expandConfig)(config));
}
exports.createClient = createClient;
/** @private */
function _createClient(config) {
    if (config.scheme !== "file") {
        throw new api_js_1.LibsqlError(`URL scheme ${JSON.stringify(config.scheme + ":")} is not supported by the local sqlite3 client. ` +
            `For more information, please read ${help_js_1.supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
    }
    const authority = config.authority;
    if (authority !== undefined) {
        const host = authority.host.toLowerCase();
        if (host !== "" && host !== "localhost") {
            throw new api_js_1.LibsqlError(`Invalid host in file URL: ${JSON.stringify(authority.host)}. ` +
                'A "file:" URL with an absolute path should start with one slash ("file:/absolute/path.db") ' +
                'or with three slashes ("file:///absolute/path.db"). ' +
                `For more information, please read ${help_js_1.supportedUrlLink}`, "URL_INVALID");
        }
        if (authority.port !== undefined) {
            throw new api_js_1.LibsqlError("File URL cannot have a port", "URL_INVALID");
        }
        if (authority.userinfo !== undefined) {
            throw new api_js_1.LibsqlError("File URL cannot have username and password", "URL_INVALID");
        }
    }
    const path = config.path;
    const options = {};
    const db = new better_sqlite3_1.default(path, options);
    try {
        executeStmt(db, "SELECT 1 AS checkThatTheDatabaseCanBeOpened");
    }
    finally {
        db.close();
    }
    return new Sqlite3Client(path, options);
}
exports._createClient = _createClient;
class Sqlite3Client {
    path;
    options;
    closed;
    /** @private */
    constructor(path, options) {
        this.path = path;
        this.options = options;
        this.closed = false;
    }
    async execute(stmt) {
        this.#checkNotClosed();
        const db = new better_sqlite3_1.default(this.path, this.options);
        try {
            return executeStmt(db, stmt);
        }
        finally {
            db.close();
        }
    }
    async batch(stmts) {
        this.#checkNotClosed();
        const db = new better_sqlite3_1.default(this.path, this.options);
        try {
            if (stmts.length > 1) {
                executeStmt(db, "BEGIN");
            }
            const resultSets = stmts.map(stmt => executeStmt(db, stmt));
            if (stmts.length > 1) {
                executeStmt(db, "COMMIT");
            }
            return resultSets;
        }
        finally {
            db.close();
        }
    }
    async transaction() {
        this.#checkNotClosed();
        const db = new better_sqlite3_1.default(this.path, this.options);
        try {
            executeStmt(db, "BEGIN");
            return new Sqlite3Transaction(db);
        }
        catch (e) {
            db.close();
            throw e;
        }
    }
    close() {
        this.closed = true;
    }
    #checkNotClosed() {
        if (this.closed) {
            throw new api_js_1.LibsqlError("The client is closed", "CLIENT_CLOSED");
        }
    }
}
exports.Sqlite3Client = Sqlite3Client;
class Sqlite3Transaction {
    database;
    /** @private */
    constructor(database) {
        this.database = database;
    }
    async execute(stmt) {
        this.#checkNotClosed();
        return executeStmt(this.database, stmt);
    }
    async rollback() {
        if (!this.database.open) {
            return;
        }
        executeStmt(this.database, "ROLLBACK");
        this.database.close();
    }
    async commit() {
        this.#checkNotClosed();
        executeStmt(this.database, "COMMIT");
        this.database.close();
    }
    close() {
        this.database.close();
    }
    get closed() {
        return !this.database.open;
    }
    #checkNotClosed() {
        if (!this.database.open) {
            throw new api_js_1.LibsqlError("The transaction is closed", "TRANSACTION_CLOSED");
        }
    }
}
exports.Sqlite3Transaction = Sqlite3Transaction;
function executeStmt(db, stmt) {
    let sql;
    let args;
    if (typeof stmt === "string") {
        sql = stmt;
        args = [];
    }
    else {
        sql = stmt.sql;
        if (Array.isArray(stmt.args)) {
            args = stmt.args.map(valueToSql);
        }
        else {
            args = {};
            for (const name in stmt.args) {
                const argName = (name[0] === "@" || name[0] === "$" || name[0] === ":")
                    ? name.substring(1) : name;
                args[argName] = valueToSql(stmt.args[name]);
            }
        }
    }
    try {
        const sqlStmt = db.prepare(sql);
        let returnsData = true;
        try {
            sqlStmt.raw(true);
        }
        catch {
            // raw() throws an exception if the statement does not return data
            returnsData = false;
        }
        if (returnsData) {
            const columns = Array.from(sqlStmt.columns().map(col => col.name));
            const rows = sqlStmt.all(args).map(sqlRow => rowFromSql(sqlRow, columns));
            // TODO: can we get this info from better-sqlite3?
            const rowsAffected = 0;
            const lastInsertRowid = undefined;
            return { columns, rows, rowsAffected, lastInsertRowid };
        }
        else {
            const info = sqlStmt.run(args);
            const rowsAffected = info.changes;
            const lastInsertRowid = BigInt(info.lastInsertRowid);
            return { columns: [], rows: [], rowsAffected, lastInsertRowid };
        }
    }
    catch (e) {
        if (e instanceof better_sqlite3_1.default.SqliteError) {
            throw new api_js_1.LibsqlError(e.message, e.code, e);
        }
        throw e;
    }
}
function rowFromSql(sqlRow, columns) {
    const row = {};
    // make sure that the "length" property is not enumerable
    Object.defineProperty(row, "length", { value: sqlRow.length });
    for (let i = 0; i < sqlRow.length; ++i) {
        const value = valueFromSql(sqlRow[i]);
        Object.defineProperty(row, i, { value });
        const column = columns[i];
        if (!Object.hasOwn(row, column)) {
            Object.defineProperty(row, column, { value, enumerable: true });
        }
    }
    return row;
}
function valueFromSql(sqlValue) {
    if (sqlValue instanceof node_buffer_1.Buffer) {
        return sqlValue.buffer;
    }
    return sqlValue;
}
function valueToSql(value) {
    if (typeof value === "bigint") {
        return "" + value;
    }
    else if (typeof value === "boolean") {
        return value ? 1 : 0;
    }
    else if (value instanceof ArrayBuffer) {
        return node_buffer_1.Buffer.from(value);
    }
    else if (value instanceof Date) {
        return value.valueOf();
    }
    else if (value === undefined) {
        throw new TypeError("undefined cannot be passed as argument to the database");
    }
    else {
        return value;
    }
}
