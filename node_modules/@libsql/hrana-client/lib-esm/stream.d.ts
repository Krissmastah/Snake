import type { Client, StreamState } from "./client.js";
import type { DescribeResult } from "./describe.js";
import { Batch } from "./batch.js";
import type { RowsResult, RowResult, ValueResult, StmtResult } from "./result.js";
import type { InSql } from "./sql.js";
import type { InStmt } from "./stmt.js";
/** A stream for executing SQL statements (a "database connection"). */
export declare class Stream {
    #private;
    /** @private */
    constructor(client: Client, state: StreamState);
    /** Execute a statement and return rows. */
    query(stmt: InStmt): Promise<RowsResult>;
    /** Execute a statement and return at most a single row. */
    queryRow(stmt: InStmt): Promise<RowResult>;
    /** Execute a statement and return at most a single value. */
    queryValue(stmt: InStmt): Promise<ValueResult>;
    /** Execute a statement without returning rows. */
    run(stmt: InStmt): Promise<StmtResult>;
    /** Return a builder for creating and executing a batch. */
    batch(): Batch;
    /** Parse and analyze a statement. This requires protocol version 2 or higher. */
    describe(inSql: InSql): Promise<DescribeResult>;
    /** Execute a sequence of statements separated by semicolons. This requires protocol version 2 or higher.
     * */
    sequence(inSql: InSql): Promise<void>;
    /** Close the stream. */
    close(): void;
    /** True if the stream is closed. */
    get closed(): boolean;
}
