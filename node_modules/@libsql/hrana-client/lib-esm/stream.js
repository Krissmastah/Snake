import { Batch } from "./batch.js";
import { describeResultFromProto } from "./describe.js";
import { ClientError } from "./errors.js";
import { stmtResultFromProto, rowsResultFromProto, rowResultFromProto, valueResultFromProto, } from "./result.js";
import { sqlToProto } from "./sql.js";
import { stmtToProto } from "./stmt.js";
/** A stream for executing SQL statements (a "database connection"). */
export class Stream {
    #client;
    #state;
    /** @private */
    constructor(client, state) {
        this.#client = client;
        this.#state = state;
    }
    /** Execute a statement and return rows. */
    query(stmt) {
        return this.#execute(stmtToProto(stmt, true), rowsResultFromProto);
    }
    /** Execute a statement and return at most a single row. */
    queryRow(stmt) {
        return this.#execute(stmtToProto(stmt, true), rowResultFromProto);
    }
    /** Execute a statement and return at most a single value. */
    queryValue(stmt) {
        return this.#execute(stmtToProto(stmt, true), valueResultFromProto);
    }
    /** Execute a statement without returning rows. */
    run(stmt) {
        return this.#execute(stmtToProto(stmt, false), stmtResultFromProto);
    }
    #execute(stmt, fromProto) {
        return new Promise((doneCallback, errorCallback) => {
            const request = {
                "type": "execute",
                "stream_id": this.#state.streamId,
                "stmt": stmt,
            };
            const responseCallback = (response) => {
                const result = response["result"];
                doneCallback(fromProto(result));
            };
            this.#client._sendStreamRequest(this.#state, request, { responseCallback, errorCallback });
        });
    }
    /** Return a builder for creating and executing a batch. */
    batch() {
        return new Batch(this.#client, this.#state);
    }
    /** Parse and analyze a statement. This requires protocol version 2 or higher. */
    describe(inSql) {
        this.#client._ensureVersion(2, "describe()");
        const { sql, sqlId } = sqlToProto(inSql);
        return new Promise((doneCallback, errorCallback) => {
            const request = {
                "type": "describe",
                "stream_id": this.#state.streamId,
                "sql": sql,
                "sql_id": sqlId,
            };
            const responseCallback = (response) => {
                const result = response["result"];
                doneCallback(describeResultFromProto(result));
            };
            this.#client._sendStreamRequest(this.#state, request, { responseCallback, errorCallback });
        });
    }
    /** Execute a sequence of statements separated by semicolons. This requires protocol version 2 or higher.
     * */
    sequence(inSql) {
        this.#client._ensureVersion(2, "sequence()");
        const { sql, sqlId } = sqlToProto(inSql);
        return new Promise((doneCallback, errorCallback) => {
            const request = {
                "type": "sequence",
                "stream_id": this.#state.streamId,
                "sql": sql,
                "sql_id": sqlId,
            };
            const responseCallback = (_response) => {
                doneCallback();
            };
            this.#client._sendStreamRequest(this.#state, request, { responseCallback, errorCallback });
        });
    }
    /** Close the stream. */
    close() {
        this.#client._closeStream(this.#state, new ClientError("Stream was manually closed"));
    }
    /** True if the stream is closed. */
    get closed() {
        return this.#state.closed !== undefined;
    }
}
