"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stream = void 0;
const batch_js_1 = require("./batch.js");
const describe_js_1 = require("./describe.js");
const errors_js_1 = require("./errors.js");
const result_js_1 = require("./result.js");
const sql_js_1 = require("./sql.js");
const stmt_js_1 = require("./stmt.js");
/** A stream for executing SQL statements (a "database connection"). */
class Stream {
    #client;
    #state;
    /** @private */
    constructor(client, state) {
        this.#client = client;
        this.#state = state;
    }
    /** Execute a statement and return rows. */
    query(stmt) {
        return this.#execute((0, stmt_js_1.stmtToProto)(stmt, true), result_js_1.rowsResultFromProto);
    }
    /** Execute a statement and return at most a single row. */
    queryRow(stmt) {
        return this.#execute((0, stmt_js_1.stmtToProto)(stmt, true), result_js_1.rowResultFromProto);
    }
    /** Execute a statement and return at most a single value. */
    queryValue(stmt) {
        return this.#execute((0, stmt_js_1.stmtToProto)(stmt, true), result_js_1.valueResultFromProto);
    }
    /** Execute a statement without returning rows. */
    run(stmt) {
        return this.#execute((0, stmt_js_1.stmtToProto)(stmt, false), result_js_1.stmtResultFromProto);
    }
    #execute(stmt, fromProto) {
        return new Promise((doneCallback, errorCallback) => {
            const request = {
                "type": "execute",
                "stream_id": this.#state.streamId,
                "stmt": stmt,
            };
            const responseCallback = (response) => {
                const result = response["result"];
                doneCallback(fromProto(result));
            };
            this.#client._sendStreamRequest(this.#state, request, { responseCallback, errorCallback });
        });
    }
    /** Return a builder for creating and executing a batch. */
    batch() {
        return new batch_js_1.Batch(this.#client, this.#state);
    }
    /** Parse and analyze a statement. This requires protocol version 2 or higher. */
    describe(inSql) {
        this.#client._ensureVersion(2, "describe()");
        const { sql, sqlId } = (0, sql_js_1.sqlToProto)(inSql);
        return new Promise((doneCallback, errorCallback) => {
            const request = {
                "type": "describe",
                "stream_id": this.#state.streamId,
                "sql": sql,
                "sql_id": sqlId,
            };
            const responseCallback = (response) => {
                const result = response["result"];
                doneCallback((0, describe_js_1.describeResultFromProto)(result));
            };
            this.#client._sendStreamRequest(this.#state, request, { responseCallback, errorCallback });
        });
    }
    /** Execute a sequence of statements separated by semicolons. This requires protocol version 2 or higher.
     * */
    sequence(inSql) {
        this.#client._ensureVersion(2, "sequence()");
        const { sql, sqlId } = (0, sql_js_1.sqlToProto)(inSql);
        return new Promise((doneCallback, errorCallback) => {
            const request = {
                "type": "sequence",
                "stream_id": this.#state.streamId,
                "sql": sql,
                "sql_id": sqlId,
            };
            const responseCallback = (_response) => {
                doneCallback();
            };
            this.#client._sendStreamRequest(this.#state, request, { responseCallback, errorCallback });
        });
    }
    /** Close the stream. */
    close() {
        this.#client._closeStream(this.#state, new errors_js_1.ClientError("Stream was manually closed"));
    }
    /** True if the stream is closed. */
    get closed() {
        return this.#state.closed !== undefined;
    }
}
exports.Stream = Stream;
